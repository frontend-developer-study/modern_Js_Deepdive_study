# 스터디 3주차

## 13장 스코프

- 식별자(변수, 함수, 클래스 이름 등)가 유효한 범위이다. 스코프에 따라 자바스크립트엔진이 어떤 식별자를 결정할 것인지 선택하기 때문에 스코프를 알아야된다.
- 스코프는 `전역`과 `지역`으로 구분할 수 있다. 전역은 코드의 가장 바깥이며, 지역은 `함수 몸체 내부`이다.
- 스코프는 중첩이 될 수 있는데, 이는 함수의 중첩으로 인해 `스코프가 계층적구조`를 가질 수 있다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프체인을 통해 변수를 참조하는데 코드의 스코프(렉시컬 환경)에서 시작하여 `상위 스코프 방향`으로 이동한다. `하위 이동하는것은 불가능`하다.
- 함수레벨스코프란 함수 내부에서 유효한 스코프의 범위를 뜻한다.
- 블록레벨스코프란 코드블록(if, for, while문등) 범위이다.
- 렉시컬 스코프란 `어디서 정의`했는지에 따라 자신의 스코프가 결정된다.

```javascript
//스코프가 단방향으로 흐른다는 증거
function foo() {
  console.log('global');
}

function bar() {
  function foo() {
    console.log('local');
  }
  foo();
}

bar();
```

## 14장 전역 변수

- 자바스크립트가 어디서든 참조하거나 불러올 수 있는 변수를 뜻한다.
- 어디서나 참조하고 할당할 수 있기 때문에 `암묵적 결합을 허용`해 위험도가 증가한다.
- 생명주기가 길기 때문에 사용하지 않는다면 `가비지컬렉터에 들어가지 않고 리소스를 차지`한다.
- 스코프체인 상에서 종점이기 때문에 `검색속도가 느리다.`
- 전역변수의 오염을 막는법
  - 즉시 실행 함수 사용
  - 이름공간 역할을 하는 객체(전역객체가 됨)를 생성하여 전역변수처럼 사용한다.
  - 클로저 기반의 모듈패턴을 활용한다.
  - ES6 모듈을 활용한다.

## 15장 var, let, const

|            |    var    |      let       |     const      |
| :--------: | :-------: | :------------: | :------------: |
|   스코프   |   전역    |      지역      |      지역      |
|   재할당   |   가능    |      가능      |     불가능     |
| 중복 선언  |   허용    |     불가능     |     불가능     |
| 스코프레벨 |   함수    |      블록      |      블록      |
|  호이스팅  |   가능    |      가능      |      가능      |
|   초기화   | undefined | ReferenceError | ReferenceError |

## 16장 내부슬롯, 내부메서드

- 자바스크립트엔진에서 실제로 동작을 위해 만들어진 것이며 개발자가 직접접근할 수 있도록 `외부로 공개되지않음`, `이중 중괄호`로 감싸져있음
- 객체에서 프로퍼티를 생성할 때 프로퍼티 내부상태를 만든다.
- 데이터프로퍼티는 `키와 값(원시값, 객체값)`으로 구성된 일반적인 프로퍼티
- 접근자프로퍼티는 자체적인 값을 갖지않고, 값을 읽거나 저장할 때 호출되는 `접근자 함수`
- 데이터프로퍼티와 접근자프로퍼티를 구별하는 방법은 value, get, set의 유무로 판단할 수 있다.
- 프로퍼티를 정의할 때 Object.getOwnPropertyDescriptior를 사용하면 writerable, enumable, configuragble등 명시적으로 정의할 수 있다.
- 객체 변경 방지하는 방법은 Object.preventExtensions, Object.seal, Object.freeze를 사용해서 변경가능하며 이것은 `데이터프로퍼티와 접근자프로퍼티의 정보를 변경`한다.
- 내부메서드는 call, constructor가 있으며, `call`의 값의 차이로 인해 객체와 함수의 `호출` 할 수 있는 여부가 다르며, `constructor`의 차이로 인해 `new 연산자`를 붙여 호출할 수 있는 생성자함수호출의 여부가 다르다.

## 17장 생성자함수

### 필요성

- 반복되는 객체를 생성하는 상황이라면 매번 객체리터럴을 사용하는건 비효율적이기 때문이다.
- this가 생성자함수가 생성할 인스턴스를 가르켜서 용이하다.

### 생성자함수 인스턴스 생성과정

1. (필수)암묵적으로 빈 객체가 생성된다.
2. (필수)빈객체에 this가 바인딩된다.
3. (옵션)생성자 함수에서 코드가 한줄씩 실행되면서 this에 바인딩되어있는 인스턴스를 초기화한다.
4. (필수)인스턴스가 반환된다. 만약 `원시값으로 반환하면 this`를 반환하고 그렇지 않으면 `지정된 객체값`을 반환한다.

## 18장 일급객체

### 함수 === 일급객체

- 무명의 리터럴로 생성할 수 있으며, 변수나 자료구조에 저장할 수 있다.
- 매개변수에 전달가능하며, 함수의 반환값으로 사용할 수 있다.

### 함수의 프로퍼티

- arguments - 전달된 인수의 정보를 가지고 있는 유사배열이며, 함수에서 실제로 받은 인수들의 개수와 같다.
- caller - 자신을 호출한 함수를 가리킨다.
- length - 선언한 매개변수의 개수를 가리키기 때문에 arguments와는 다른 속성이다.
- name - 함수의 이름
- \_\_proto\_\_ - 부모로부터 상속받은 객체를 뜻한다.
- prototype - 생성자함수로 호출할 수 있는 함수 객체 → constructor만 소유하는 프로퍼티이다.

---

### 2회차 스터디 깊은 복사 예제

```javascript
const person = { name: '철수', age: 20 };

function changeName(obj, name) {
  const copyObj = { name: obj.name, age: obj.age };
  copyObj.name = name;

  return copyObj;
}

console.log(person);
console.log(changeName(person, '영희'));
```
