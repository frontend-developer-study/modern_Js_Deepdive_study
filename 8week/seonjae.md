## 42장 비동기 프로그래밍

### 싱글스레드

한 번에 하나의 태스크만 실행할 수 있는 방식

### 동기 처리 방식

- 태스크를 순서대로 하나씩 처리하는 방식
- 장점: 실행 순서가 보장된다.
- 단점: 이전 태스크가 종료될 때까지 이후 태스크들은 블로킹 된다.

### 비동기 처리 방식

- 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식
- 종류: setTimeout, setInterval, HTTP 요청, 이벤트 핸들러
- 장점: 실행 중인 태스크가 종료되지 않아도 다음 태스크를 곧바로 실행하므로 블로킹문제는 해결됨
- 단점: 실행 순서가 보장되지 않음

### 자바스크립트엔진 구성

- 힙: 객체가 저장되는 메모리 공간이다. 메모리에 저장할 공간의 크기는 `구조화되어있지 않고` 런타임에 동적으로 정해진다.
- 콜 스택: 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조이다.

### 브라우저 환경

- 태스크 큐: 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
- 이벤트 루프: 브라우저에 내장된 `기능` 중 하나이며, 자바스크립트의 동시성을 지원한다. 콜 스택에 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다. 콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 순차적으로 대기 중인 함수를 콜스택으로 전달한다.

### 브라우저에 대한 오해

- 브라우저는 `싱글 스레드가 아니다!` → 자바스크립트엔진, 렌더링엔진, WebAPI등을 병렬적으로 실행해야되기 때문이다.
- 만약 싱글스레드라면 setTimeout의 시간설정, 만료시 콜백함수 호출이 불가능 할 것이다.

---

## 43장 Ajax

- 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 `동적으로 갱신`하는 프로그래밍

**직렬화:** 클라이언트가 서버로 객체를 전송하려면 객체를 문자열화 해야하는 과정

**역직렬화**: 서버로부터 클라이언트에게 전송된 문자열을 객체화 시키는 과정

---

## 44장 REST API

- HTTP 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처이며 이를 기반으로 서비스 API를 구현한 것이다.
- 자원, 행위, 표현의 3가지 요소로 구성된다.

---

## 45장 프로미스

### **콜백패턴의 필요성**

1. 비동기 함수의 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수 없다.
2. 비동기 함수에 대한 후속처리는 콜백함수를 통해 처리해야된다.

### **프로미스**

- 비동기 처리 상태와 처리 결과를 관리하는 객체이다.
- 콜백패턴의 문제점을 해결가능
  - 콜백패턴은 콜백함수의 호출이 중첩되면서 `복잡도`가 높아진다.
  - 콜백패턴은 `에러처리가 가능하지 않다.`
- 상태 결과는 pending, fufilled, rejected가 있다.
- then, catch, finally 후속 메서드가 있다.

### 마이크로태스크 큐

- 마이크로태스크 큐에는 `프로미스의 후속 처리 메서드인 콜백함수`가 저장된다.
- 태스크큐보다 마이크로태스크 큐가 우선순위가 높아 콜스택이 비어있고 마이크로태스크큐와 태스크큐에 태스크가 각각 있다면 마이크로태스크큐부터 콜스택으로 이동한다.

---

## 46장 제너레이터와 async/await

### 제너레이터

- 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수
- 제너레이터 함수는 함수 호출자에게 양도(yeild)할 수 있다.
- 함수호출자와 상태를 주고받을 수 있다.
- 제너레이터 함수 호출 시 제너레이터 객체를 반환한다.
  - 제너레이터 객체는 이터러블이면서 동시에 이터레이터이다. next로 호출이 가능하다.
- yield와 next 키워드를 사용해 필요한 시점에 함수를 재개할 수 있다.
- yield: 제너레이터 함수의 실행을 일시 중지시키거나 yeild 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.
- next: 키워드를 사용하면 제너레이터 함수의 다음 yield까지 실행된다.

```jsx
const takeFood = function* () {
  const bowl = '그릇';

  const food =
    yield '음식 담기전입니다.\n제너레이터객체의 첫번째 메서드에 음식배열을 넣어주세요.';

  yield `${food} 준비완료 되었습니다.`;

  return `${bowl}에 ${food}가 담겼습니다.`;
};

const fruits = takeFood();

console.log(fruits.next().value);
console.log(fruits.next(['딸기', '수박', '참외']).value);
console.log(fruits.next().value);
```

### async/await

- async함수는 `프로미스 객체를 반환`하며, 암묵적으로 `resolve를 반환`하는 함수이다.
- try…catch문을 사용해 에러를 캐치할 수 있으며, 동기처리처럼 동작하게 할 수 있다.
- 하나의 함수에 다양한 프로미스가 있다면 Promise.all객체를 활용해서 호출하는 것이 좋다.

---

## 47장 에러핸들링

1. 단축평가, 옵셔널 체이닝 연산자를 통해 처리하기
2. try…catch…finally문을 통해 처리하기(권장)

### Error 객체

- Error는 생성자 함수를 포함해 7가지의 에러객체를 생성할 수 있다.
- try…catch…finally문에 에러로 검출되기 위해서는 throw를 통해 호출해야 한다.
- 에러는 상위 실행컨텍스트로 전파되기 때문에 `호출자 방향으로 전파`된다.

```jsx
const foo = () => {
  throw new Error('foo Error');
};

const bar = () => {
  foo();
};

const zar = () => {
  try {
    bar();
  } catch (err) {
    console.log(err);
  }

  throw new Error('zar Error');
};

const kar = () => {
  zar();
};

try {
  kar();
} catch (error) {
  console.log(error);
}
```

---

## 48장 모듈

- 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.
- 일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다.

### 자바스크립트의에서 모듈

기존의 자바스크립트는 파일을 불러올 때 `script` 태그를 사용해서 불러왔다. 하지만 다른 script태그로 불러와도 모두 하나의 파일로 간주하기 때문에 전역 오염 이슈가 발생했다. 이를 해결하기 위해 모듈 시스템을 도입하게 되는데 자바스크립트에서는 CommonJS와 ESM을 다룬다.

- CommonJS: Node.js에서 표준으로 사용하고 있다.
- ESM: 클라이언트 사이드에서 사용하고 있다. script 태그에 `type=”module”`을 추가해서 사용한다.
