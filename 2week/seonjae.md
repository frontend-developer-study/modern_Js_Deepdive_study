## 11장 객체리터럴

객체: `프로퍼티`와 `메서드`로 구성된 집합체이다.

객체를 생성하는 방법

- 객체리터럴: {}
- Object생성자 함수: new Object()
- 생성자 함수: new functionName()
- Object.create
- 클래스(ES6)

메서드: 프로퍼티 값이 `함수`인 경우

프로퍼티: 키와 값으로 구성된다. 프로퍼티는 동적생성, 삭제가 가능하며, 값만 갱신도 가능하다.

프로퍼티를 접근할 수 있는 방법

1. 객체에 접근연산자(.)을 이용하는 마침법 표기법
2. 객체에 접근연산자([..])을 이용해 대괄호 표기법

사용시 주의할 점은 네이밍 규칙을 준수해야 오류가 나지 않는다.

## 12장 원시 값과 객체의 비교

| 비교 |  원시  |  객체  |
| :--: | :----: | :----: |
| 변경 | 불가능 |  가능  |
|  값  | 실제값 | 참조값 |

문자열: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 `유사배열객체`이다.

|      비교      | 얕은복사 | 깊은복사 |
| :------------: | :------: | :------: |
| 기존 객체 비교 |   다름   |   다름   |
|    복사단계    |  1단계   | 모든단계 |

## 13장 함수

함수

- 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위를 정의한 것
- 객체는 호출하지 못하지만 함수는 호출이 가능하다.
- 일급객체로 평가되어 `값처럼 쓸 수 있다.` return을 안하면 값은 undefined

함수 호이스팅 - 변수 호이스팅인 경우 선언되기 이전에 호출을 하게 되면 할당되기 이전이어서 undefined가 되지만, 함수호이스팅은 `호출되기 이전에 선언했어도 참조와 호출이가능`하다. 하지만 함수표현식은 함수를 변수에 할당하는 방식이기 때문에 `변수 호이스팅`이라는 차이점이 있다.

### 함수정의방법

```jsx
//함수선언문
function 함수이름() {}
//함수표현식
const func = function 함수이름() {};
//Function 생성자함수
const func = new Function();
//화살표함수
const func = () => {};
```

### 함수의 형태

```jsx
//즉시실행함수
(function () {}());
(function add() {}());
//재귀함수
function fact(n) {
	if(n <= 1) return 1;  //탈출조건
	return n * fact(n-1); //재귀호출
}
//중첩함수
function outer() {
	function inner();
	inner();
}
//콜백함수
function repeat(n, f) {
	for(let i=0; i<n; i++) {
		f(i);
	}
}
//순수함수
function increase(n) { return ++n;}
//비순순함수
let count = 0;
function increase() { return ++count;}
```
