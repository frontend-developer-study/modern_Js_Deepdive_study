10장 객체 리터럴

10.1 객체란?

<script>

let person = {
    name: 'name', //키
    age: '333' //값
};

// 1.기본적으로 객체는 프로퍼티 집합이다.
// 2.프로퍼티 키와 값으로 구성됨.
// 3.객체 타입은 변경 가능한 값이다.

// *원시 타입의 값은 변경이 불가능하다.

let ID='rudejr333' //문자열 원시 타입
ID[0] // 값은 r
ID[0] = 'a'; // ID[0]에 'r' 대신 'a'를 넣어도 변경되지 않음.
ID


10.3 프로퍼티

let counter = {
    nem:0,  //프로퍼티
    increase: () => { //메서드
        this.num++;
    },
    '네이밍-규칙-무시' : '반드시 따옴표로 같이 써야함.'
};

// 프로퍼티 : 객체의 상태를 나타내는 값(data)
// 메서드 : 프러퍼티(상태 데이터)를 참조하고 조작할 수 있는 동장(behavior)
// 네이밍 규칙에 따옴표를 빼면 표현식으로 인식하여 오류가 나옴 unexpected token
// 표현식은 값으로 평가될 수 있는 문이다. ex let num =10+2


//*객체를 같은 키로 중복 선언시 나중에 선언 된것이 적용됨.

let foo = {
    name: 'rrr',
    name: 'uuu'
}
foo //{name: 'uuu'}



10.4 메서드

//프로 퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.
//메서드는 객체에 묶여 있는 함수를 의미한다.
// 메서드 내부에서 사용한 this는 객체 자신을 가리키는 참조변수다.
let circle ={
    age: 5, //프로퍼티
    agePlus(){ //메서드
        return this.age ++;
    }
}

10.5 프로퍼티 접근
// 키가 식별자 네이밍 규칙을 준수하면 마침표와 대과로 둘자 사용가능 아니라면 대괄호만 사용가능.
// 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법 
// 대괄호 프로퍼티 접근 연산자([ ... ])를 사용하는 대괄호 표기법

let person ={
    name: '이름',
    1:'숫자'
};
person.name // 마침표 표기법 값은 '이름'
person.1 // 에러 unexpected number
person['name'] // 대괄호 표기법 값은 '이름'
person[name] // 따옴표로 감싸지 않고 사용시 식별자로 인식하여 오류가 나옴. name is not defined
person[1] // 단 프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표 생략 가능.

10.6 프로퍼티 값 갱신
// 프로퍼티는 객체의 상태를 나타내는 값이다.
person.name = '갱신'

10.7 프로퍼티 동적 생성
person.age = 20;

10.8 프로퍼티 삭제
delete person.age;
delete person.address; // 프로퍼티가 존재하지 않으면 무시되고 에러가 발생하지 않음.

11 원시 값과 객체의 비교
//7가지 데이터 타입(숫자,문자,불리언,null,undefined,심벌,객체 타입)

//원시 타입(객체 타입 빼고 전부)
// 원시 값을 변수에 할당시 변수에는 실제 값이 저장됨.
// 원시 값을 다른 변수에 할당시 원본의 원시 값이 복사되어 전달됨.

//객체 타입(객체 타입)
// 객체를 변수에 할당시 변수에 참조 값이 저장됨.
// 객체 값을 다른 벼수에 할당시 참조 값이 복사되어 전달됨.

11.1 원시 값
// 한번 생성된 원시 값은 변경 불가능한 값으로 읽기 전용 값이다.
// 변수 값은 변경 가능하여 변수에 값을 할당시 재할당으로 수정 가능하다.

12.3 함수 리터럴
*함수 이름
// 식별자 네임이 규칙을 준수해야한다.
// 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.
// 함수 이름은 생략할 수 있다. 이름이 있을 경우 기명 함수 없을 경우 무명/익명 함수라함.

*매개변수 목록
// 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다
function add( 매개변수1 , 매개변수2){
   return 매개변수1 + 매개변수2;
}
// 각 매개변수는 함수를 호출할 때 지정한 인수가 순서대로 할당됨.
// 매개변수는 함수 몸체 내에서 변수와 동일하게 취급됨.

*함수 몸체
// 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
// 함수 몸체는 함수 호출에 의해 실행됨.
add(첫번때 인자, 두번째 인자);

//**리터럴은 값을 생성하기 위한 표기법이다.

12.4 함수 정의
//일반 객체는 호출할 수없지만 함수는 호출할 수있다.
//일반 객체란 뭘까?
//-개인 적인 생각
//* 설명에 변수 선언과 함수 정의
//변수는 선언 한다고 했지만 함수는 정의한다고 표현했다.
// 함수 선언문이 평가되면 식별자가 암묵적으로 생선되고 함수 객체가 할당괸다.
// 따라서 ECMAScript 사양에서도 변수에는 선언, 함수에는 정의 라고 표현 한다.
// 객체 자체로 선언되어 있는 것을 일반객체라 하지 않을까 생각을함.
let 객체 = {'키':'값'};


12.4.2 함수 표현식
//일급 객체란
//값처럼 변수에 할당 가능
//프로퍼티 값이 될 수 있음 (객체내부에 들어갈 수 있음.)
//배열 요소도 될 수 있음.

12.4.3 함수 생성 시점과 함수 호이스팅

add(2,5); //7
sub(2,5); //undefined

//함수 선언문
function add(x,y){
    return x+y;
}

// 함수 표현식(변수 할당문)
let sub = function (x,y){
    return x-y
}

//함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실해됨.
// 이것을 함수 호이스팅이라함.
// 변수 호이스팅과 차이는 값 초기화 후 할당을 하지마 함수는 함수 자체를 선언문 이전에 호출함.
//함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생함.


12.5.2 인수확인
예제 12-24
function add(a=0,b=0,c=0){
    return a + b + c;
}

//매개변수는 몇개인게 좋을까
// 매개변수 개수는 0개이고 적을 수록 좋다
// 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.

12.7 다양한 함수의 형태
//많이 알려주지만 책에 마지막에서는 역시 첫번째걸 사용한다고 했다 그정도만 알고있자.
//즉시 실행문
(function(){
    
}());


12.7.2 재귀 함수
//for문을 사용하지 않고 자기 자신을 원하는 값까지 계속 호출함.
// 책에서도 여러 위험이 있으니 반복문 보다 직관적인 경우에만 사용할 것이라 한다.

function count(n) {
    if(n==10) return n=0;
    n++
    console.log(n)
    count(n)
}

count(0);


12.7.4 콜백함수
// 함수의 매개변수를 통해 다른 함수 내부로 전달되는 함수를 콜백 함수라함.

12.7.5 순수 함수와 비순수 함수
// 외부 값을 의존하지 않고 변경하지 않는 함수는 순수 함수
// 외부 값을 의존하고 외부 상태를 변경하는 함수를 비순수 함수

//예를 들어 setTimeout() 사용하겠다.
//setTimeout() 함수는 일정 시간 후 함수를 호출해줌.

let n = 0;
function count() {
    if(n==10) return n=0;
    n++
    console.log(n)
    setTimeout(count,1000);
}
count();

// setTimeout이라는 함수를 이용해서 자기자신을 콜백한 것
// 외부에 있는 n이라는 전역함수를 계속해서 수정함.